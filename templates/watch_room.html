{% extends "layout.html" %}

{% block title %}Sala de Cine{% endblock %}

{% block head_styles %}
<style>
    body { background-color: black; margin: 0; display: flex; height: 100vh; overflow: hidden; }
    #main-content { flex-grow: 1; height: 100%; display: flex; flex-direction: column; position: relative; }
    #video-container { flex-grow: 1; background-color: black; display: flex; justify-content: center; align-items: center; }
    video { width: 100%; height: 100%; object-fit: contain; }
    .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; transition: opacity 0.5s; color: white; }
    .overlay.hidden { opacity: 0; pointer-events: none; }
    #admin-controls { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.7), transparent); padding: 20px; display: flex; flex-direction: column; z-index: 50; opacity: 0; transition: opacity 0.3s; }
    #video-container:hover #admin-controls, #admin-controls.forced-visible { opacity: 1; }
    #play-pause-btn { background: none; border: none; color: white; font-size: 2em; cursor: pointer; } #progress-bar { width: 100%; }

    /* Los estilos del chat ahora vienen del fichero _chat_ui.html y el layout.html global */
</style>
{% endblock %}

{% block content %}
<div id="main-content">
    <div id="video-container">
        <video id="video-player" playsinline muted></video>
        {% if is_admin %}
        <div id="admin-controls" class="forced-visible">
            <div class="controls-top">
                <button id="play-pause-btn">▶️</button>
                <input type="range" id="progress-bar" value="0" step="1">
            </div>
        </div>
        {% endif %}
    </div>
</div>

<!-- INICIO DE LA GRAN MEJORA: Usamos el parcial del chat -->
{% set room_type = 'watch_room' %}
{% include "partials/_chat_ui.html" %}
<!-- FIN DE LA GRAN MEJORA -->


<div class="overlay" id="unmute-overlay"><h2>Haz clic para activar el sonido</h2></div>
<div class="overlay hidden" id="countdown-overlay"><h2><span id="countdown-timer">5</span></h2></div>
{% endblock %}

{% block scripts %}
<!-- INICIO DE LA GRAN MEJORA: cargamos el script de chat central -->
<script src="{{ url_for('static', filename='js/chat_logic.js') }}"></script>
<!-- FIN DE LA GRAN MEJORA -->

<script>
// Este script ahora solo se encarga de la LÓGICA DEL VÍDEO
document.addEventListener('DOMContentLoaded', () => {
    // Esperamos a que el socket del chat_logic esté listo
    const socketCheckInterval = setInterval(() => {
        if (window.chatApp && window.chatApp.socket) {
            clearInterval(socketCheckInterval);
            setupVideoPlayer(window.chatApp.socket);
        }
    }, 100);

    function setupVideoPlayer(socket) {
        const sessionId = "{{ session_id }}";
        const isAdmin = {{ is_admin | tojson }};

        const elements = {
            video: document.getElementById('video-player'),
            unmuteOverlay: document.getElementById('unmute-overlay'),
            countdownOverlay: document.getElementById('countdown-overlay'),
            countdownTimer: document.getElementById('countdown-timer'),
            adminControls: document.getElementById('admin-controls'),
            playPauseBtn: document.getElementById('play-pause-btn'),
            progressBar: document.getElementById('progress-bar')
        };
        let playlist = [], currentServerState = {}, localPlaylistIndex = -1, isSeeking = false;

        function logClientError(message, errorData = null) {
            console.error(`[CLIENT ERROR ${sessionId}]: ${message}`, errorData);
            // Podrías enviar esto al servidor también si tuvieras un endpoint de logging
            // socket.emit('client_error', { session_id: sessionId, error: message, data: errorData });
        }

        function applyState(newState, forceSrc = false) {
            console.log(`[applyState ${sessionId}]: Recibido nuevo estado:`, JSON.parse(JSON.stringify(newState)), `Forzar SRC: ${forceSrc}`);
            currentServerState = newState; // Actualizar el estado de referencia del servidor

            if (!newState || typeof newState.current_video_index === 'undefined') {
                logClientError("Estado inválido o índice de video no definido.", newState);
                return;
            }

            if (!playlist || playlist.length === 0) {
                logClientError("Playlist no disponible o vacía al aplicar estado.", playlist);
                // Podríamos solicitar la playlist aquí si fuera necesario
                return;
            }

            const newPlaylistIndex = newState.current_video_index;
            if (newPlaylistIndex < 0 || newPlaylistIndex >= playlist.length) {
                logClientError(`Índice de video fuera de rango: ${newPlaylistIndex}. Longitud de Playlist: ${playlist.length}`, newState);
                return; // Evitar error fatal
            }

            const currentVideoData = playlist[newPlaylistIndex];
            if (!currentVideoData || !currentVideoData.src) {
                logClientError(`Datos del video actual inválidos o sin 'src' en el índice ${newPlaylistIndex}.`, currentVideoData);
                return; // Evitar error fatal
            }

            console.log(`[applyState ${sessionId}]: Aplicando video: ${currentVideoData.src}, Tiempo: ${newState.time}, Playing: ${newState.playing}`);

            // Actualizar fuente del video si es necesario (cambio de video o forzado)
            const newVideoSrc = `/static/${currentVideoData.src}`;
            if (forceSrc || !elements.video.src.includes(currentVideoData.src) || localPlaylistIndex !== newPlaylistIndex) {
                console.log(`[applyState ${sessionId}]: Cambiando src del video a: ${newVideoSrc}`);
                elements.video.src = newVideoSrc;
                localPlaylistIndex = newPlaylistIndex; // Actualizar índice local
                if (elements.progressBar) {
                    elements.progressBar.max = currentVideoData.duration || 3600;
                    elements.progressBar.value = newState.time || 0; // Asegurar que la barra se actualice con el tiempo del nuevo video
                }
                 // Cuando se cambia el src, el video se pausa. Esperar a que se cargue para sincronizar.
                elements.video.load(); // Es importante llamar a load() después de cambiar src
            }

            // Sincronizar tiempo y estado de reproducción una vez que los metadatos estén cargados (o si ya lo están)
            const syncVideoProperties = () => {
                // Sincronizar tiempo si la diferencia es significativa
                if (Math.abs(elements.video.currentTime - newState.time) > 1.5) { // Reducido umbral para inicio más rápido
                    console.log(`[applyState ${sessionId}]: Ajustando currentTime de ${elements.video.currentTime} a ${newState.time}`);
                    elements.video.currentTime = newState.time;
                }

                // Sincronizar estado de reproducción (play/pause)
                if (newState.playing && elements.video.paused) {
                    console.log(`[applyState ${sessionId}]: Intentando reproducir video.`);
                    elements.video.play().catch(e => {
                        logClientError('Error al intentar video.play() en applyState.', e);
                        // Podría ser necesario mostrar de nuevo el unmuteOverlay si el error es por interacción
                        if (e.name === "NotAllowedError" && elements.video.muted) {
                            elements.unmuteOverlay.classList.remove('hidden');
                        }
                    });
                } else if (!newState.playing && !elements.video.paused) {
                    console.log(`[applyState ${sessionId}]: Pausando video.`);
                    elements.video.pause();
                }
            };

            if (elements.video.readyState >= HTMLMediaElement.HAVE_METADATA) {
                syncVideoProperties();
            } else {
                elements.video.onloadedmetadata = () => {
                    console.log(`[applyState ${sessionId}]: Metadatos cargados para ${elements.video.src}. Sincronizando propiedades.`);
                    syncVideoProperties();
                    elements.video.onloadedmetadata = null; // Limpiar listener para evitar múltiples llamadas
                };
            }

            // Actualizar controles de admin
            if (isAdmin && elements.playPauseBtn && elements.progressBar) {
                elements.playPauseBtn.textContent = newState.playing ? '⏸️' : '▶️';
                if (!isSeeking) elements.progressBar.value = newState.time;
            }
        }

        elements.unmuteOverlay.addEventListener('click', () => {
            elements.video.muted = false;
            elements.unmuteOverlay.classList.add('hidden');
        });
        elements.video.addEventListener('click', () => {
            if(!elements.unmuteOverlay.classList.contains('hidden')) {
                elements.video.muted = false;
                elements.unmuteOverlay.classList.add('hidden');
            }
        });

        if (isAdmin && elements.playPauseBtn && elements.progressBar) {
            elements.playPauseBtn.addEventListener('click', () => socket.emit('admin_action', { session_id: sessionId, action: 'state_change', state: { playing: elements.video.paused, time: elements.video.currentTime }}));
            elements.progressBar.addEventListener('input', () => isSeeking = true);
            elements.progressBar.addEventListener('change', () => {
                isSeeking = false;
                socket.emit('admin_action', { session_id: sessionId, action: 'state_change', state: { time: parseFloat(elements.progressBar.value) }});
            });
        }
        
        elements.video.addEventListener('stalled', () => socket.emit('request_state_sync', { session_id: sessionId }));
        elements.video.addEventListener('error', () => setTimeout(() => socket.emit('request_state_sync', { session_id: sessionId }), 1000));

        // Los listeners de chat ya no están aquí
        socket.on('initial_state', (data) => {
            console.log(`[initial_state ${sessionId}]: Recibido:`, JSON.parse(JSON.stringify(data)));
            playlist = data.playlist; // Guardar la playlist
            if (!playlist || playlist.length === 0) {
                logClientError("Playlist vacía o no definida en initial_state.", data);
            }
            // Aplicar el estado solo si la sesión está activa.
            // Si está en vestíbulo, no se hace nada con el video aquí.
            if (data.state && data.state.status === 'active') {
                applyState(data.state, true); // Forzar src para el primer video
            } else {
                console.log(`[initial_state ${sessionId}]: Sesión no activa o sin estado, no se aplica estado de video.`);
            }
        });

        socket.on('state_change', (newState) => {
            console.log(`[state_change ${sessionId}]: Recibido:`, JSON.parse(JSON.stringify(newState)));
            // No forzar src aquí a menos que el video haya cambiado (lo cual debería venir por play_next_video)
            applyState(newState);
        });

        socket.on('sync_pulse', (data) => {
            // Solo aplicar si el estado actual del servidor indica que está reproduciendo
            // y el video local no está ya muy cerca del tiempo del servidor.
            if (currentServerState && currentServerState.playing && elements.video && !elements.video.paused && !isSeeking) {
                if (Math.abs(data.time - elements.video.currentTime) > 1.5) { // Umbral ajustado
                    console.log(`[sync_pulse ${sessionId}]: Ajustando tiempo de ${elements.video.currentTime} a ${data.time}`);
                    elements.video.currentTime = data.time;
                }
                if (isAdmin && elements.progressBar) {
                    elements.progressBar.value = data.time;
                }
            }
        });

        socket.on('play_next_video', (data) => {
            console.log(`[play_next_video ${sessionId}]: Recibido:`, JSON.parse(JSON.stringify(data)));
            applyState(data.state, true); // Forzar cambio de src
        });

        socket.on('playback_starting', (data) => {
            console.log(`[playback_starting ${sessionId}]: Recibida cuenta atrás: ${data.countdown}`);
            elements.countdownOverlay.classList.remove('hidden');
            let count = data.countdown;
            elements.countdownTimer.textContent = count;
            const interval = setInterval(() => {
                count--;
                elements.countdownTimer.textContent = count > 0 ? count : '¡Disfruta!';
                if (count <= 0) { clearInterval(interval); setTimeout(() => elements.countdownOverlay.classList.add('hidden'), 1000); }
            }, 1000);
        });
    }
});
</script>
{% endblock %}